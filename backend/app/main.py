from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from app.models.schemas import UserProfile, DietPlanResponse
from app.logic.planner import generate_plan_logic
import os

# Create the FastAPI app instance
app = FastAPI(
    title="Personalized Nutrition Planner API",
    description="An API that generates personalized diet plans based on user health data.",
    version="1.0.0"
)

# --- Middleware ---
# This allows your frontend (running on a different domain) to make requests to this backend.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Allow the Next.js frontend
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],  # Allow specific methods
    allow_headers=["*"],  # Allows all headers.
)


# --- API Endpoints ---

@app.get("/", tags=["Root"])
def read_root():
    """A simple endpoint to check if the API is running."""
    return {"status": "ok", "message": "Welcome to the Nutrition Planner API!"}


@app.post("/api/generate-plan", response_model=DietPlanResponse, tags=["Planner"])
async def generate_plan_endpoint(user_profile: UserProfile):
    """
    This is the main endpoint.
    It receives user data (disease, symptoms, age, gender) and returns a
    personalized diet and recipe plan generated by the RAG pipeline.
    """
    try:
        # 1. Call the core logic function from planner.py
        # This function does all the heavy lifting: RAG, data processing, and Gemini call.
        print(f"Received request for user profile: {user_profile.dict()}")
        plan_content = await generate_plan_logic(user_profile)

        # 2. Return the generated content in the defined response structure
        return {"plan": plan_content}
    except Exception as e:
        # A general error handler to catch any unexpected issues in the logic
        print(f"‚ùå An unexpected error occurred: {e}")
        raise HTTPException(status_code=500, detail="An internal server error occurred.")
