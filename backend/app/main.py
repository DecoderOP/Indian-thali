import uvicorn
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from neo4j import GraphDatabase, basic_auth
from dotenv import load_dotenv

# Import the new functions from our refactored planner
from .models.schemas import UserProfile, DietPlanResponse
from .logic.planner import generate_plan_logic, startup_load_models
import os

# --- CONFIGURATION ---
load_dotenv()

# IMPORTANT: Update these with your Neo4j database credentials
# These MUST match the credentials you used in migrate_to_graph.py
NEO4J_URI = "neo4j://localhost:7687"
NEO4J_USER = "neo4j"
# Make sure this is the same password you used to run the migration
NEO4J_PASSWORD = "Thali@1938" # <-- EDIT THIS IF NEEDED
# --- END CONFIGURATION ---


# Use a "lifespan" event to manage global resources
# This is the modern replacement for @app.on_event("startup")
@asynccontextmanager
async def lifespan(app: FastAPI):
    # --- Code to run ON STARTUP ---
    print("--- FastAPI app starting up... ---")
    
    # 1. Initialize Neo4j Driver
    try:
        app.state.neo4j_driver = GraphDatabase.driver(NEO4J_URI, auth=basic_auth(NEO4J_USER, NEO4J_PASSWORD))
        app.state.neo4j_driver.verify_connectivity()
        print("✅ Successfully connected to Neo4j.")
    except Exception as e:
        print(f"❌ CRITICAL: Failed to connect to Neo4j. {e}")
        # In a real app, you might want to exit if the DB connection fails
        app.state.neo4j_driver = None
    
    # 2. Load AI models and CSV data for mapping
    # We still need these for the "RAG" part of Graph RAG
    app.state.ai_models = startup_load_models()
    print("✅ AI models and mapping data loaded.")
    
    # --- End of Startup ---
    yield
    # --- Code to run ON SHUTDOWN ---
    print("--- FastAPI app shutting down... ---")
    if app.state.neo4j_driver:
        app.state.neo4j_driver.close()
        print("✅ Neo4j connection closed.")

# Initialize FastAPI app with the lifespan manager
app = FastAPI(
    title="Personalized Nutrition Planner API (GraphRAG Version)",
    description="An API that generates personalized diet plans using a Neo4j GraphRAG pipeline.",
    version="2.0.0",
    lifespan=lifespan
)

# --- Middleware ---
# This allows your frontend (running on a different domain) to make requests to this backend.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Allow the Next.js frontend
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],  # Allow specific methods
    allow_headers=["*"],  # Allows all headers.
)


# --- API Endpoints ---

@app.get("/", tags=["Root"])
def read_root():
    """A simple endpoint to check if the API is running."""
    return {"status": "ok", "message": "Welcome to the Nutrition Planner GraphRAG API!"}


@app.post("/api/generate-plan", response_model=DietPlanResponse, tags=["Planner"])
async def generate_plan_endpoint(user_profile: UserProfile, request: Request):
    """
    This is the main endpoint.
    It receives user data (disease, symptoms, age, gender) and returns a
    personalized diet and recipe plan generated by the RAG pipeline.
    """
    
    # Access the global state (neo4j driver, ai models)
    neo4j_driver = request.app.state.neo4j_driver
    ai_models = request.app.state.ai_models
    
    if not neo4j_driver:
        raise HTTPException(status_code=503, detail="Database connection is not available.")
    
    if not ai_models:
        raise HTTPException(status_code=503, detail="AI models are not loaded.")

    try:
        # 1. Call the new core logic function from planner.py
        # We now pass the database driver and models to it
        print(f"Received request for user profile: {user_profile.dict()}")
        plan_content = await generate_plan_logic(user_profile, neo4j_driver, ai_models)

        # 2. Return the generated content in the defined response structure
        return {"plan": plan_content}
    except Exception as e:
        # A general error handler to catch any unexpected issues in the logic
        print(f"❌ An unexpected error occurred: {e}")
        raise HTTPException(status_code=500, detail="An internal server error occurred.")

# Note: This block is not needed if running with uvicorn command
# if __name__ == "__main__":
#     uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True)

